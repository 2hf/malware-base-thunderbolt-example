#pragma once
#include <Windows.h>
#include <string>
#include <fstream>
#include <iostream>
#include <string>
#include <array>
#include <cstdarg>
#include <dbghelp.h>
#include <deque>
#include <tlhelp32.h>
#include <time.h>
#include <ostream>
#include <Psapi.h>
#include <thread>
#include <processthreadsapi.h>
#include <queue>
#include <unordered_map>
#include <stack>
#include <random>
#include <filesystem>
#pragma comment(lib, "dbghelp.lib")
using byte = unsigned char;
// [--------| Private library! |---------]
// Security/Protection library
// [--------| Private library! |---------]
// turn off all optimizations to ensure function entropy works properly.
// some features are from github, though most are not public methods
namespace thunderbolt {
	constexpr auto _time = __TIME__;
	constexpr auto seed = static_cast<int>(_time[7]) + static_cast<int>(_time[6]) * 10 + static_cast<int>(_time[4]) * 60 + static_cast<int>(_time[3]) * 600 + static_cast<int>(_time[1]) * 3600 + static_cast<int>(_time[0]) * 36000;

	// 1988, Stephen Park and Keith Miller
	// "Random Number Generators: Good Ones Are Hard To Find", considered as "minimal standard"
	// Park-Miller 31 bit pseudo-random number generator, implemented with G. Carta's optimisation:
	// with 32-bit math and without division
	template < int N >
	struct random_generator_s
	{
	private:
		static constexpr unsigned a = 16807; // 7^5
		static constexpr unsigned m = 2147483647; // 2^31 - 1

		static constexpr unsigned s = random_generator_s< N - 1 >::value;
		static constexpr unsigned lo = a * (s & 0xFFFF); // Multiply lower 16 bits by 16807
		static constexpr unsigned hi = a * (s >> 16); // Multiply higher 16 bits by 16807
		static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16); // Combine lower 15 bits of hi with lo's upper bits
		static constexpr unsigned hi2 = hi >> 15; // Discard lower 15 bits of hi
		static constexpr unsigned lo3 = lo2 + hi;

	public:
		static constexpr unsigned max = m;
		static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
	};

	template <>
	struct random_generator_s< 0 >
	{
		static constexpr unsigned value = seed;
	};

	template < int N, int M >
	struct RandomInt
	{
		static constexpr auto value = random_generator_s< N + 1 >::value % M;
	};

	template < int N >
	struct RandomChar
	{
		static const char value = static_cast<char>(1 + RandomInt< N, 0x7F - 1 >::value);
	};

	template < size_t N, int K, typename Char >
	struct c_xor_string
	{
	private:
		const char _key;
		std::array< Char, N + 1 > _encrypted;

		constexpr Char enc(Char c) const
		{
			return c ^ _key;
		}

		Char dec(Char c) const
		{
			return c ^ _key;
		}

	public:
		template < size_t... Is >
		constexpr __forceinline c_xor_string(const Char* str, std::index_sequence< Is... >) : _key(RandomChar< K >::value), _encrypted{ enc(str[Is])... }
		{
		}

		__forceinline decltype(auto) decrypt(void)
		{
			for (size_t i = 0; i < N; ++i) {
				_encrypted[i] = dec(_encrypted[i]);
			}
			_encrypted[N] = '\0';
			return _encrypted.data();
		}
	};

#define _( s ) []{ constexpr thunderbolt::c_xor_string< sizeof(s)/sizeof(char) - 1, __COUNTER__, char > expr( s, std::make_index_sequence< sizeof(s)/sizeof(char) - 1>() ); return expr; }().decrypt()
#define _w( s ) []{ constexpr thunderbolt::c_xor_string< sizeof(s)/sizeof(wchar_t) - 1, __COUNTER__, wchar_t > expr( s, std::make_index_sequence< sizeof(s)/sizeof(wchar_t) - 1>() ); return expr; }().decrypt()


	class c_function {
	public:
		void* m_nFunc;
		DWORD m_dwSize;
		c_function(void* func, void* stub) {
			this->m_nFunc = func;
#ifdef DEBUG
			std::cout << "{+} got function\n";
#endif
			this->m_dwSize = get_size(func, stub);
#ifdef DEBUG
			std::cout << "{+} got function size\n";
#endif
		}

		DWORD get_size(void* Function, void* Stub) {
			DWORD dwFuncSize = 0, dwOldProtect;
			DWORD* fnA, * fnB;
			fnA = (DWORD*)Function;
			fnB = (DWORD*)Stub;
			dwFuncSize = fnB - fnA;
			VirtualProtect(fnA, dwFuncSize, PAGE_EXECUTE_READWRITE, &dwOldProtect);
			return dwFuncSize;
		}
	};

	class c_entropy {
	public:
		std::deque<c_function> m_arrFunctions;
		void add_element(c_function x) {
			m_arrFunctions.push_back(x);
#ifdef DEBUG
			std::cout << "{+} added function to array\n";
#endif
		}
		void erase_functions() {
			if (!m_arrFunctions.size())
				return;
			for (auto at : m_arrFunctions) {
#ifdef DEBUG
				std::cout << "{+} function addr: " << at.m_nFunc << std::endl;
#endif
				* (byte*)at.m_nFunc = 0xC3;
#ifdef DEBUG
				std::cout << "{+} inserted retn to function\n";
#endif
				DWORD oldProtect;
				VirtualProtect(at.m_nFunc, at.m_dwSize, PAGE_EXECUTE_READWRITE, &oldProtect);
				memset(at.m_nFunc, 0xcc, at.m_dwSize);
#ifdef DEBUG
				std::cout << "{+} erased function\n";
#endif
			}
		}
	};
};


